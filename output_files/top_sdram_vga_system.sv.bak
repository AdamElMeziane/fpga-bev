// Complete SDRAM-VGA Display System
// Based on proven EP4CE6 SDRAM controller architecture
// Displays 320x240 image from ROM via SDRAM buffering

module top_sdram_vga_system (
    input  logic        clk_50MHz,
    input  logic        reset_n,
    input  logic        start_button,      // Button to start image loading

    // VGA outputs
    output logic [0:0]  vga_red,
    output logic [0:0]  vga_green,
    output logic [0:0]  vga_blue,
    output logic        vga_hsync,
    output logic        vga_vsync,

    // SDRAM interface
    inout  wire [15:0]  dq,
    output logic        sclk,
    output logic        cke,
    output logic        cs_n,
    output logic        ras_n,
    output logic        cas_n,
    output logic        we_n,
    output logic [11:0] addr,
    output logic [1:0]  bank,
    output logic        udqm,
    output logic        ldqm,
    
    // Status LEDs (for debugging)
    output logic [3:0]  status_leds
);

    // Clock generation
    logic clk_133, clk_25, pll_locked;
    logic reset_sync_133, reset_sync_25;

    // PLL for clock generation
    pll_133Mhz pll_inst (
        .areset(~reset_n),
        .inclk0(clk_50MHz),
        .c0(clk_133),          // 133MHz for SDRAM
        .locked(pll_locked)
    );

    // Generate 25MHz VGA clock
    logic [1:0] clk_div;
    always_ff @(posedge clk_50MHz or negedge reset_n) begin
        if (!reset_n) begin
            clk_div <= 2'b00;
        end else begin
            clk_div <= clk_div + 1;
        end
    end
    assign clk_25 = clk_div[1];

    // Reset synchronizers
    always_ff @(posedge clk_133 or negedge reset_n) begin
        if (!reset_n) begin
            reset_sync_133 <= 1'b0;
        end else begin
            reset_sync_133 <= pll_locked;
        end
    end

    always_ff @(posedge clk_25 or negedge reset_n) begin
        if (!reset_n) begin
            reset_sync_25 <= 1'b0;
        end else begin
            reset_sync_25 <= 1'b1;
        end
    end

    // Button synchronizer
    logic start_sync1, start_sync2, start_pressed;
    always_ff @(posedge clk_133 or negedge reset_sync_133) begin
        if (!reset_sync_133) begin
            start_sync1 <= 1'b0;
            start_sync2 <= 1'b0;
        end else begin
            start_sync1 <= start_button;
            start_sync2 <= start_sync1;
        end
    end
    assign start_pressed = start_sync2;

    //========================================================================
    // SDRAM Controller Signals
    //========================================================================
    logic sdram_start;
    logic sdram_enable_write_mode, sdram_enable_read_mode;
    logic [15:0] sdram_incoming_data, sdram_outgoing_data;
    logic sdram_enable_transmitter, sdram_enable_receiver;

    assign sdram_start = pll_locked;

    sdram_controller #(
        .CLK_FREQ_MHZ(133.0),
        .PWR_DELAY_NS(200000.0),
        .CAS_LATENCY(3),
        .MAX_ROWS(4096),
        .MAX_COLS(256),
        .DATA_WIDTH(16)
    ) sdram_ctrl (
        .rst_n(reset_sync_133),
        .clk(clk_133),
        .start(sdram_start),
        .enable_write_mode(sdram_enable_write_mode),
        .enable_read_mode(sdram_enable_read_mode),
        .incoming_data(sdram_incoming_data),
        .outgoing_data(sdram_outgoing_data),
        .enable_transmitter(sdram_enable_transmitter),
        .enable_receiver(sdram_enable_receiver),
        .dq(dq),
        .sclk(sclk),
        .cke(cke),
        .cs_n(cs_n),
        .ras_n(ras_n),
        .cas_n(cas_n),
        .we_n(we_n),
        .addr(addr),
        .bank(bank),
        .udqm(udqm),
        .ldqm(ldqm)
    );

    //========================================================================
    // Image Loader (ROM to SDRAM)
    //========================================================================
    logic loader_loading_complete;
    logic loader_enable_write;

    image_loader #(
        .IMG_WIDTH(320),
        .IMG_HEIGHT(240),
        .DATA_WIDTH(16)
    ) img_loader (
        .rst_n(reset_sync_133),
        .clk(clk_133),
        .start_loading(start_pressed),
        .sdram_ready(pll_locked),
        .sdram_tx_enable(sdram_enable_transmitter),
        .pixel_data(sdram_incoming_data),
        .enable_write_mode(loader_enable_write),
        .loading_complete(loader_loading_complete)
    );

    //========================================================================
    // VGA Timing Generator
    //========================================================================
    logic vga_video_on, vga_frame_start;
    logic [9:0] vga_x, vga_y;

    vga_display_controller #(
        .IMG_WIDTH(320),
        .IMG_HEIGHT(240)
    ) vga_ctrl (
        .clk_vga(clk_25),
        .rst_n(reset_sync_25),
        .hsync(vga_hsync),
        .vsync(vga_vsync),
        .video_on(vga_video_on),
        .x(vga_x),
        .y(vga_y),
        .frame_start(vga_frame_start),
        .fifo_read_enable(fifo_read_enable),
        .fifo_data(fifo_read_data),
        .fifo_empty(fifo_empty),
        .fifo_half_full(fifo_half_full),
        .rgb(vga_rgb)
    );

    //========================================================================
    // FIFO Buffer (Clock Domain Crossing)
    //========================================================================
    logic fifo_write_enable, fifo_read_enable;
    logic [15:0] fifo_write_data, fifo_read_data;
    logic fifo_full, fifo_empty, fifo_half_full;

    fifo_buffer #(
        .ADDR_WIDTH(9),    // 512 entries for good buffering
        .DATA_WIDTH(16)
    ) pixel_fifo (
        .rst_n(reset_sync_133 & reset_sync_25),
        .clk_write(clk_133),
        .clk_read(clk_25),
        .write_enable(fifo_write_enable),
        .write_data(fifo_write_data),
        .fifo_full(fifo_full),
        .read_enable(fifo_read_enable),
        .read_data(fifo_read_data),
        .fifo_empty(fifo_empty),
        .fifo_half_full(fifo_half_full)
    );

    //========================================================================
    // VGA Frame Reader (SDRAM to FIFO)
    //========================================================================
    logic reader_enable_read_mode;
    logic reader_frame_ready;

    vga_frame_reader #(
        .IMG_WIDTH(320),
        .IMG_HEIGHT(240),
        .DATA_WIDTH(16)
    ) frame_reader (
        .rst_n(reset_sync_133),
        .clk_sdram(clk_133),
        .clk_vga(clk_25),
        .sdram_ready(loader_loading_complete),
        .sdram_rx_enable(sdram_enable_receiver),
        .sdram_data(sdram_outgoing_data),
        .enable_read_mode(reader_enable_read_mode),
        .frame_start(vga_frame_start),
        .video_on(vga_video_on),
        .vga_x(vga_x),  
        .vga_y(vga_y),
        .fifo_write_enable(fifo_write_enable),
        .fifo_write_data(fifo_write_data),
        .fifo_full(fifo_full),
        .fifo_half_full(fifo_half_full),
        .frame_ready(reader_frame_ready)
    );

    //========================================================================
    // Control Logic
    //========================================================================
    
    // SDRAM mode control - prioritize loading first, then reading
    assign sdram_enable_write_mode = loader_enable_write && !loader_loading_complete;
    assign sdram_enable_read_mode = reader_enable_read_mode && loader_loading_complete;

    //========================================================================
    // VGA Output Assignment
    //========================================================================
    logic [2:0] vga_rgb;
    assign vga_red[0]   = vga_rgb[2];
    assign vga_green[0] = vga_rgb[1];
    assign vga_blue[0]  = vga_rgb[0];

    //========================================================================
    // Status LEDs for Debugging
    //========================================================================
    assign status_leds[0] = pll_locked;
    assign status_leds[1] = loader_loading_complete;
    assign status_leds[2] = reader_frame_ready;
    assign status_leds[3] = !fifo_empty;

endmodule